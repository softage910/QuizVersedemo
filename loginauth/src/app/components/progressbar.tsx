"use client";
import React, { useEffect, useState } from "react";
import { ref, onValue, query,  get } from "firebase/database";
import "./progressbar.css";
import { database } from "../firebase/firebaseconfig";

// type User = {
//   type: string;
//   uid: string;
// };

const ProgressBar = () => {
  const [progressData, setProgressData] = useState<Record<string, Record<string, boolean>> | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const totalTasks = 8;
  const [currentDayTasks, setCurrentDayTasks] = useState<Record<string, boolean>>({});
  const [userDetails, setUserDetails] = useState<{ name: string; uid: string } | null>(null);
  const [userID, setUserID] = useState<string>("");

  useEffect(() => {
    const userData = localStorage.getItem("userDetails");
    const invitedUsers = sessionStorage.getItem("invitedUsers");

    if (userData) {
      setUserDetails(JSON.parse(userData));
    }

    if(invitedUsers){
      setUserID(invitedUsers);
    }
  }, []);

  // useEffect(() => {
  //   const fetchProgress = async () => {
  //     if (userDetails && userDetails.uid) {
  //       const usersRef = ref(database, 'users');
  //       const userQuery = query(usersRef, orderByChild('uid'), equalTo(userDetails.uid));

  //       try {
  //         const snapshot = await get(userQuery);
  //         if (snapshot.exists()) {
  //           const userData = snapshot.val();
  //           const autoGeneratedId = Object.keys(userData)[0];

  //           const progressRef = ref(database, `users/${autoGeneratedId}/progress`);

  //           onValue(progressRef, (snapshot) => {
  //             if (snapshot.exists()) {
  //               setProgressData(snapshot.val());
  //                       // Find the current day
  //                       for (const [tasks] of Object.entries(snapshot.val())) {
  //                         if (Object.values(tasks).includes(false)) {
  //                           setCurrentDayTasks(tasks);
  //                           break;
  //                         }
  //                       }
  //             } else {
  //               setProgressData({});
  //             }
  //             setTimeout(() => setIsLoading(false), 2000); // Smooth transition
  //           });
  //           } else {
  //           console.log("User not found in database.");
  //         }
  //       } catch (error) {
  //         console.error("Error fetching user data:", error);
  //       }
  //     }
  //   };


  //   fetchProgress();
  // }, [userDetails]);

  useEffect(() => {
    const UserEmail = sessionStorage.getItem("userEmail");

    const fetchProgress = async () => {
      if (userID) {
        const usersRef = ref(database, `invitedUsers`);
        const userQuery = query(usersRef);

        try {
          const snapshot = await get(userQuery);
          if (snapshot.exists()) {
            const userData = snapshot.val();
            const autoGeneratedId = Object.keys(userData).find(
              (key) => userData[key].email === UserEmail
          );
            const progressRef = ref(database, `invitedUsers/${autoGeneratedId}/progress`);

            onValue(progressRef, (snapshot) => {
              if (snapshot.exists()) {
                const progressData = snapshot.val();

                if (progressData) { // ‚úÖ Ensure it's not null
                  setProgressData(progressData);
                  // for (const [day, tasks] of Object.entries(progressData)) {
                  //   if (typeof tasks === "object" && Object.values(tasks).includes(false)) {
                  //     setCurrentDayTasks(tasks as Record<string, boolean>); 
                  //     break;
                  //   }
                  // }
                  for (const [, tasks] of Object.entries(progressData)) {
                    if (
                      tasks &&
                      typeof tasks === "object" &&
                      !Array.isArray(tasks) &&
                      Object.values(tasks as Record<string, boolean>).includes(false)
                    ) {
                      setCurrentDayTasks(tasks as Record<string, boolean>);
                      break;
                    }
                  }

                }
              } else {
                setProgressData({});
              }

              setTimeout(() => setIsLoading(false), 2000);
            });
          } else {
            console.log("User not found in database.");
          }
        } catch (error) {
          console.error("Error fetching user data:", error);
        }
      }
    };

    fetchProgress();
  }, [userDetails]);


  // Define custom sorting logic
  const sortedProgressEntries = progressData
  ? Object.entries(progressData)
      .filter(([key]) => key.startsWith("Day")) // ‚¨ÖÔ∏è Only include "Day" keys
      .sort(([a], [b]) => {
        const dayNumberA = parseInt(a.match(/\d+/)?.[0] || "0", 10);
        const dayNumberB = parseInt(b.match(/\d+/)?.[0] || "0", 10);
        return dayNumberA - dayNumberB;
      })
  : [];




  if (isLoading) {
    return (
      <div className="loading-container">
        <div className="spinner"></div>
        <p className="loading-text">Fetching Progress<span className="dots"></span></p>
      </div>
    );
  }

  // Calculate completed tasks
  // const completedTasks = progressData
  //   ? Object.values(progressData).reduce(
  //     (count, day) => count + Object.values(day).filter((task) => task === true).length,
  //     0
  //   )
  //   : 0;

  const completedTasks = sortedProgressEntries.reduce(
    (count, [, day]) =>
      count + Object.values(day).filter((task) => task === true).length,
    0
  );
  

  // Calculate progress percentage
  const progressPercentage = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;

  let currentDay = "Day1"; // Default to Day1 if no data exists

  if (progressData) {
    const allDays = Object.keys(progressData);
    // const lastDay = allDays[allDays.length - 1]; // Get the last available day

    let foundIncomplete = false;

    // for (const [day, tasks] of Object.entries(progressData)) {
    //   if (Object.values(tasks).includes(false)) {
    //     currentDay = `${day}`;
    //     foundIncomplete = true;
    //     break;
    //   }
    // }

    const formatDay = (dayKey: string) => {
      return dayKey.replace(/Day(\d+)/, 'Day $1');
    };
    
    for (const [day, tasks] of sortedProgressEntries) {
      if (Object.values(tasks).includes(false)) {
        currentDay = formatDay(day); // üëà Add space between Day and number
        foundIncomplete = true;
        break;
      }
    }
    
    if (!foundIncomplete && sortedProgressEntries.length > 0) {
      const lastDay = sortedProgressEntries[sortedProgressEntries.length - 1][0];
      currentDay = formatDay(lastDay); // üëà Also format last day if all are completed
    }
    
  }

  return (
    <div className="container">
      <div className="progress">
        <div
          className="progress-bar progress-bar-striped"
          role="progressbar"
          style={{
            width: `${progressPercentage}%`,
            backgroundColor: "#0281d4",
          }}
        >
          <div style={{ color: '#f8b400' }}>{progressPercentage.toFixed(2)}%</div>
          <div className="triangle"></div>
          <div className="progress-value">
            <span className="glowing-text">{currentDay}</span>
          </div>
        </div>
      </div>

      <div className="task-cards">
        {Object.entries(currentDayTasks)
.sort(([taskA], [taskB]) => {
  const isModuleA = taskA.toLowerCase().startsWith("module");
  const isModuleB = taskB.toLowerCase().startsWith("module");

  const isAssessmentA = taskA.toLowerCase().startsWith("assessment");
  const isAssessmentB = taskB.toLowerCase().startsWith("assessment");

  // Group modules first
  if (isModuleA && !isModuleB) return -1;
  if (!isModuleA && isModuleB) return 1;

  // If both are modules or both are assessments, sort by number
  const numA = parseInt(taskA.match(/\d+/)?.[0] || (isAssessmentA ? "99" : "0"), 10);
  const numB = parseInt(taskB.match(/\d+/)?.[0] || (isAssessmentB ? "99" : "0"), 10);

  return numA - numB;
})

          .map(([taskName, isCompleted], index) => (
            <div
              key={taskName}
              className={`task-card ${isCompleted ? "completed" : "pending"} fade-in`}
              style={{ animationDelay: `${index * 0.2}s` }}
            >
              <h3>{taskName}</h3>
              <p>{isCompleted ? "‚úÖ" : "‚ùå"}</p>
            </div>
          ))}


      </div>
    </div>
  );
};

export default ProgressBar;
